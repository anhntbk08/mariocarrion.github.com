<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Mario Carrion</title><link>https://www.mariocarrion.com/</link><description>Recent content on Mario Carrion</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 04 Aug 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://www.mariocarrion.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Gitlab Tip: Generating documentation with mermaid</title><link>https://www.mariocarrion.com/2019/08/04/gitlab-mkdocs-mermaid-pages.html</link><pubDate>Sun, 04 Aug 2019 00:00:00 +0000</pubDate><guid>https://www.mariocarrion.com/2019/08/04/gitlab-mkdocs-mermaid-pages.html</guid><description>One best practice we follow regarding documentation is to keep it close to what it describes, we prefer including those files together with the actual code, in a different docs/ folder. We write them in Markdown because it is a simple and easy to understand format that is automatically rendered correctly when browsing those files in Gitlab.
And because we are Gitlab users, we are also able to use other features like Gitlab pages and the mermaid support in markdown to generate even better and useful documentation.</description></item><item><title>Go Tool: ifacecodegen</title><link>https://www.mariocarrion.com/2019/07/17/golang-tools-ifacecodegen.html</link><pubDate>Wed, 17 Jul 2019 00:00:00 +0000</pubDate><guid>https://www.mariocarrion.com/2019/07/17/golang-tools-ifacecodegen.html</guid><description>Similar to counterfeiter we use another tool called ifacecodegen that allows us to automatically generate code from interface definitions using a Go template.
ifacecodegen is used to generate code that satisfies an interface type and wraps the existing type implementing said interface, think of middleware code that will be used for logging purposes (using logurs) or collecting metrics (using NewRelic).
For example, assuming you have code that follows the DDD paradigm (where there&amp;rsquo;s a Repository/Data Store and some sort of Service/Use Case):</description></item><item><title>Go Tool: counterfeiter</title><link>https://www.mariocarrion.com/2019/06/24/golang-tools-counterfeiter.html</link><pubDate>Mon, 24 Jun 2019 00:00:00 +0000</pubDate><guid>https://www.mariocarrion.com/2019/06/24/golang-tools-counterfeiter.html</guid><description>counterfeiter has been one of those tools we can not live without when building software in Go, specially because we build our enterprise systems using Domain Driven Design and we heavily use Dependency Injection to properly separate and test layers independently.
I briefly mentioned counterfeiter in my previous Go Tool post, this time I will dive a bit deeper.
counterfeiter is useful when using generate directives in your code to automatically generate Fakes/Doubles/Mocks from dependent interfaces you define in your code.</description></item><item><title>Finished Reading: Event Streams in Action</title><link>https://www.mariocarrion.com/2019/06/17/event-stream-in-action.html</link><pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate><guid>https://www.mariocarrion.com/2019/06/17/event-stream-in-action.html</guid><description>Event Streams in Action is a book written by Alexander Dean and Valentin Crettaz, published in May 2019 by Manning Publications.
Event Streams in Action centers around the unified log, it specifically uses Apache Kafka and AWS Kinesis as concrete platforms to exemplify how event streaming works, similar to other in Action books, Event Streams follows the pattern where each chapter covers one concrete topic, using either Kafka or Kinesis, it introduces hyphotetical companies from different industries to get the point accross.</description></item><item><title>Go Tip: Server to Server Authentication &#43; Azure Active Directory</title><link>https://www.mariocarrion.com/2019/06/06/server-to-server-authentication-azure-active-directory.html</link><pubDate>Thu, 06 Jun 2019 00:00:00 +0000</pubDate><guid>https://www.mariocarrion.com/2019/06/06/server-to-server-authentication-azure-active-directory.html</guid><description>Last time we used Azure Active Directory for authenticating real users, this time let&amp;rsquo;s do something similar but instead of doing it for real users let&amp;rsquo;s do it for Server Side authentication, basically allow one service authenticate with another one, server side, thanks to Azure Active Directory.
Prerequisites You have already a working service that uses Azure Active Directory for Authentication, this is the service we are going to connect to, this is the server, make sure you have its Application ID You are familiar with Azure Active Directory, so you can follow the setup instructions below Setting it up Similar to the server, register a new Azure Active Directory, there&amp;rsquo;s no need to input a Redirect URI, this is the client Edit that newly created app, go to the Certificates &amp;amp; secrets section (on the left side), and add a New client secret save this value somewhere, this is the secret image full size</description></item><item><title>Finished Reading: Secure by Design</title><link>https://www.mariocarrion.com/2019/05/30/secure-by-design.html</link><pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate><guid>https://www.mariocarrion.com/2019/05/30/secure-by-design.html</guid><description>Secure by Design is a book written by Dan Bergh Johnsson, Daniel Deagun and Daniel Sawano, to be published in two months, in July 2019 by Manning Publications. This review covers the MEAP release of this book, specifically Version 13.
Secure by Design is a fascinating read because the approach it takes to cover security it&amp;rsquo;s really interesting. It focuses completely on designing systems with secure primitives in mind from the beginning, considers networking interactions (and their possible issues for preventing them, like circuit breakers and timeouts) as well as some software development techniques to use (like fuzzing and automatic dependency checks) to detect problems before delivering the final product.</description></item><item><title>Go Tool: retool</title><link>https://www.mariocarrion.com/2019/04/17/golang-tools-twitchtv-retool.html</link><pubDate>Wed, 17 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.mariocarrion.com/2019/04/17/golang-tools-twitchtv-retool.html</guid><description>One of toughest things in Go is versioning, for library dependencies there are different ways to handle this, vendoring automatically using a tool like dep, which is the de facto most popular tool for doing so, or using modules, which happens to be the new official workflow.
For tools that you depend on, for example for generating code (like counterfeiter or go-swagger) or linters (like golangci-lint), things get a bit more complicated, sure you could hack your PATH to point to different versions and use docker for wrapping those commands and specific versions; but that is definitely messy and not sustainable in the long run.</description></item><item><title>nit: MVP release</title><link>https://www.mariocarrion.com/2019/04/04/2019-nit-mvp-release.html</link><pubDate>Tue, 09 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.mariocarrion.com/2019/04/04/2019-nit-mvp-release.html</guid><description>Beginning of the year I described my plans for this year, one thing I wanted to complete by the end of February was finishing nit, the opinionated code organization linter, it took longer than expected but it is finally available and more importantly it&amp;rsquo;s on production and being actively used.
The most recent version to date is v0.6.0, to install it:
Using go (&amp;lt; 11.1): go install github.com/MarioCarrion/nit/cmd/nit or download a precompiled release.</description></item><item><title>Finished Reading: Hands-On Sofware Architecture with Golang</title><link>https://www.mariocarrion.com/2019/02/05/hands-on-software-architecture-golang.html</link><pubDate>Tue, 05 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.mariocarrion.com/2019/02/05/hands-on-software-architecture-golang.html</guid><description>Hands-On Software Architecture with Golang is a book written by Jyotiswarup Raiturkar and published in December 2018 by Packt.
Finding good Software Architecture books in the market is though, specifically for an evolving programing language such as Go, to my surprise Hands-On Software Architecture with Golang delivers relevant content that helps you get an idea about what is like to using Go for designing and implementing scalable Software Architectures.
Hands-On Software Architecture with Golang touches a little bit of everything related to Software Architecture: Software Design, Design Patterns, Scalability Considerations, Messaging, Serialization and Database Design, just to mention a few.</description></item><item><title>Finished Reading: Software Architect&#39;s Handbook</title><link>https://www.mariocarrion.com/2019/01/23/software-architects-handbook.html</link><pubDate>Wed, 23 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.mariocarrion.com/2019/01/23/software-architects-handbook.html</guid><description>I&amp;#39;m pleasantly surprised with &amp;quot;Software Architect&amp;#39;s Handbook&amp;quot;, good content, up to date and relevant to recent trends and best practices. pic.twitter.com/UFkvKzr99H
&amp;mdash; Mario Carrion (@mariocarrion) January 23, 2019 Software Architect&amp;rsquo;s Handbook is a book written by Joseph Ingeno and published in August 2018 by Packt.
I like approaching Packt books with caution because sometimes the content seems rushed and lacks quality, and some others the content is good and polished, it&amp;rsquo;s kind of a flip of coin with this publisher.</description></item><item><title>Go &#43; Docker Tip: Private repos and Gitlab CI</title><link>https://www.mariocarrion.com/2019/01/04/go-docker-private-repos-gitlab-ci.html</link><pubDate>Fri, 04 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.mariocarrion.com/2019/01/04/go-docker-private-repos-gitlab-ci.html</guid><description>It&amp;rsquo;s been a few years since I shared a really useful tip related to Gitlab and GitlabCI. This time it&amp;rsquo;s about a few things to considering when building a Go programs using Docker, Docker in Docker, Gitlab CI and more importantly private git repositories that happen to represent Go binaries or/and Go packages.
Prerequisites To make this work there are 2 requirements:
You have previous experience building Go programs with Docker using multi staged builds, and You already have a working GitlabCI Docker pipeline that uses Docker in Docker.</description></item><item><title>Envisioning 2019</title><link>https://www.mariocarrion.com/2019/01/03/2019-looking-back-at-2018.html</link><pubDate>Thu, 03 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.mariocarrion.com/2019/01/03/2019-looking-back-at-2018.html</guid><description>2018 was greater than 2017, professionally and personally I was able to achieve the things I wanted to and planned to do.
Professionally 100% Go-fication started!, I grew my Backend team!, I was promoted and given more responsibility!, Our team was able to deliver the first phase of our new proprietary platform, and We made sure our existing platform was able to handle all the traffic coming from the newly acquired Time Inc properties, which is more than 6 times than before!</description></item><item><title>Top 5 books in 2018</title><link>https://www.mariocarrion.com/2018/12/29/top-5-books-in-2018.html</link><pubDate>Sat, 29 Dec 2018 00:00:00 +0000</pubDate><guid>https://www.mariocarrion.com/2018/12/29/top-5-books-in-2018.html</guid><description>As the year comes to an end I want to go back and do a final review of all the books I completed this year, as a reminder regarding reading books every year I always want to achieve two things:
Read more books than the previous year (26 in 2017), and Break my own record (31 in 2016). Sadly, I wasn&amp;rsquo;t able to achieve either goal because I only finished reading 20 books (to be fair the other 3 in the queue are almost completed), I must commit next year and try again.</description></item><item><title>nit: the opinionated Go linter</title><link>https://www.mariocarrion.com/2018/12/27/nit-the-opinionated-linter.html</link><pubDate>Thu, 27 Dec 2018 00:00:00 +0000</pubDate><guid>https://www.mariocarrion.com/2018/12/27/nit-the-opinionated-linter.html</guid><description>I&amp;rsquo;ve blogged in the past about the importance of having concrete rules and conventions when developing software, specially when a team is in charge of writing that said software. It becomes more problematic the larger the team is, it is not a big deal with smaller projects (which correlate to not having a lot of team members), but the bigger the team the more difficult it is to make sure everybody follows the same rules.</description></item><item><title>Finished Reading: Microservices Patterns</title><link>https://www.mariocarrion.com/2018/12/05/microservices-patterns.html</link><pubDate>Wed, 05 Dec 2018 00:00:00 +0000</pubDate><guid>https://www.mariocarrion.com/2018/12/05/microservices-patterns.html</guid><description>&amp;quot;Microservices Patterns&amp;quot; is a long read, well put together and really relevant to what&amp;#39;s trending. pic.twitter.com/AVtZK1OvlH
&amp;mdash; Mario Carrion (@mariocarrion) December 5, 2018 Microservices Patterns: with examples in Java is a book published by Manning in October 2018 and written by Chris Richardson.
Microservices Patterns is a long read, but worth the time investment, that covers practically everything you need to know to properly implement Microservices.
There&amp;rsquo;s a lot covered in the book that requires the reader to have some previous knowledge, I can see it being hard to follow without knowing some concepts in advance, and in the end it won&amp;rsquo;t be beneficial because you won&amp;rsquo;t be able to get the most out of the content.</description></item></channel></rss>