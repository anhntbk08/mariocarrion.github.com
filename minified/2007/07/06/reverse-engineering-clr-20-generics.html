<!doctype html><html lang=en-us><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=HandheldFriendly content=True><meta name=MobileOptimized content=320><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content=no-referrer><meta name=author content="Mario Carrion"><meta name=description content="There are two goals with this new Reverse Engineering API:
 Implement an extensible, clean and easy-to-use Reverse Engineering API, hiding complex things by using UML-magic methods. Implement CIL plugin by using this new API, to read 1.1 and 2.0 CLR assemblies.  To accomplish second goal I decided to use Cecil instead of Reflection because, IMO, Cecil has a cleaner API (not yet documented, but going to sources helps and, of course, you can always ask) and thinking on the future we might read the full assembly (including method body, for example) to define some diagrams, such as Sequence Diagram."><meta property=og:title content="Reverse Engineering CLR 2.0 Generics"><meta property=og:description content="There are two goals with this new Reverse Engineering API:
 Implement an extensible, clean and easy-to-use Reverse Engineering API, hiding complex things by using UML-magic methods. Implement CIL plugin by using this new API, to read 1.1 and 2.0 CLR assemblies.  To accomplish second goal I decided to use Cecil instead of Reflection because, IMO, Cecil has a cleaner API (not yet documented, but going to sources helps and, of course, you can always ask) and thinking on the future we might read the full assembly (including method body, for example) to define some diagrams, such as Sequence Diagram."><meta property=og:type content=article><meta property=og:url content=https://www.mariocarrion.com/2007/07/06/reverse-engineering-clr-20-generics.html><meta property=article:published_time content=2007-07-06T03:41:10&#43;00:00><meta property=article:modified_time content=2007-07-06T03:41:10&#43;00:00><title>Reverse Engineering CLR 2.0 Generics</title><link rel=canonical href=https://www.mariocarrion.com/2007/07/06/reverse-engineering-clr-20-generics.html><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Inconsolata:400,700" rel=stylesheet><link rel=stylesheet href=/css/reset.css><link rel=stylesheet href=/css/main.css><link rel="shortcut icon" href=/favicon.png><link rel=alternate type=application/rss+xml title="RSS Feed" href=/index.xml><body><section class=header><div class=container><div class=content><a href=/><img class=avatar src=/img/logo.png></a>
<a href=/><div class=name>Mario Carrion</div></a><nav><ul><li class=nav-about><a href=https://www.mariocarrion.com/about.html><span>About</span></a><li class=nav-archive><a href=https://www.mariocarrion.com/archive.html><span>All Posts</span></a><li class=nav-books><a href=https://www.mariocarrion.com/books.html><span>Books</span></a><li class=nav-resume><a href=https://docs.google.com/document/d/1i0W6qNfGMhTfwWTHBaaKzlN9HLGwbk3GLeh8VtVlhNM><span>Resume</span></a></ul></nav></div></div></section><section class=icons><div class=container><div class=content><a href=/index.xml><img class=icon src=/img/rss.svg alt=rss></a>
<a href=//github.com/MarioCarrion target=_blank rel=noopener><img class=icon src=/img/github.svg alt=github></a>
<a href=//twitter.com/MarioCarrion target=_blank rel=noopener><img class=icon src=/img/twitter.svg alt=twitter></a>
<a href=//linkedin.com/in/MarioCarrion target=_blank rel=noopener><img class=icon src=/img/linkedin.svg alt=linkedin></a></div></div></section><section class="main post non-narrow zero-top-spacing"><div class=container><div class=content><div class=front-matter><div class=title-container><div class=page-heading>Reverse Engineering CLR 2.0 Generics</div><div class=initials><a href=https://www.mariocarrion.com></a></div></div><div class=meta><div class=date title="Fri Jul 6 2007 03:41:10 UTC">Jul 06, 2007</div></div></div><div class=markdown><p>There are two goals with this new Reverse Engineering API:<ol><li>Implement an extensible, clean and easy-to-use Reverse Engineering API, hiding complex things by using UML-magic methods.<li>Implement CIL plugin by using this new API, to read 1.1 and 2.0 CLR assemblies.</ol><p>To accomplish second goal I decided to use <a href=http://www.mono-project.com/Cecil>Cecil</a> instead of <a href=http://msdn2.microsoft.com/en-us/library/system.reflection(VS.71).aspx>Reflection</a> because, IMO, Cecil has a cleaner API (not yet documented, but going to sources helps and, of course, you can <a href=http://groups.google.com.mx/group/mono-cecil>always ask</a>) and thinking on the future we might read the full assembly (including method body, for example) to define some diagrams, such as <a href=http://en.wikipedia.org/wiki/Sequence_diagram>Sequence Diagram</a>.<p>Most notable difference between first version and this new one, is the 2.0 CIL support, and reverse engineering Generics isn't that easy, to do so the following are my ideas to face and finish both implementations:<ol><li>Refactor CIL plugin to handle on a clean way all the Cecil's TypeReference, including PointerType, ArrayType, ReferenceType and GenericInstanceType. Today am using the if-else-if "pattern" not even close to best solution.<li>Test nUML to handle Templates, I did some tests and many worked, template binding and XMI exporting seems to crash, however template definition doesn't. The following is my test case:</ol><p><code lang=csharp>using System;<br>using System.IO;<br>using NUml.Xmi2;<br>using NUml.Uml2;<p>class MainClass<br>{<br>public static void Main(string[] args)<br>{<br>DataType TObj = Create.DataType ();<br>TObj.Name = "TKey";<br>DataType KObj = Create.DataType ();<br>KObj.Name = "TValue";<br>TemplateSignature signature = Create.TemplateSignature ();<br>ClassifierTemplateParameter T = Create.ClassifierTemplateParameter ();<br>ClassifierTemplateParameter K = Create.ClassifierTemplateParameter ();<br>T.Signature = signature;<br>T.Default = TObj;<br>K.Signature = signature;<br>K.Default = KObj;<br>signature.Parameter.Add (T);<br>signature.Parameter.Add (K);<br>Class klass = Create.Class ();<br>/* Systems.Collection.Dictionary`2[TKey , TValue] emulation */<br>klass.Name = "Dictionary";<br>klass.OwnedTemplateSignature = signature;<p>SerializationDriver driver = new SerializationDriver ();<br>driver.AddSerializer (new NUml.Uml2.Serialization.Serializer ());<br>driver.Serialize (new object [] { klass, T, K, TObj, KObj },<br>Console.OpenStandardOutput(), "urn:numl.sourceforge.net:testing:templates");<br>}<p>}</code><ol start=3><li>Implement the MonoUML visualizer, to show the Parameters defined on the Templates.<li>Test, test and test.</ol><p>If you are wondering about Templates and so on, UML 2 Super Structure (05-07-04) defines them from page 600 to 631, go ahead.<br><p class=back-to-posts><a href=/archive.html>Back to posts</a></div><br><div class=disqus></div></div></div></section>