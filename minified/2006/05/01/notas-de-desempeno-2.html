<!doctype html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Mario Carrion - Notas de desempeÃ±o, 2</title><meta name=author content="Mario Carrion"><meta name=description content="The blog of Mario Carrion"><link rel=canonical href=http://www.mariocarrion.com/2006/05/01/notas-de-desempeno-2.html><link href="//fonts.googleapis.com/css?family=Inconsolata:400,700" rel=stylesheet><link rel="shortcut icon" href=/favicon.png><link rel=stylesheet href=/css/base.css><link rel=stylesheet href=/css/skeleton.css><link rel=stylesheet href=/css/screen.css><link rel=stylesheet href=/css/layout.css><link rel=stylesheet href=//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css><div class=container><div class="four columns sidebar"><nav><h1>Hello stranger!</h1><a href=/><img src=/images/logo.png id=logo alt="Blog logo" class=circular></a><h1>I&#39;m <a href=/about.html>Mario Carrion</a></h1><hr><ul id=blog-pages class=posts><li><span>&raquo; </span><a href=/about.html>About me</a><li><span>&raquo; </span><a href=/books.html>Books</a><li><span>&raquo; </span><a href=/disclaimer.html>Disclaimer</a><li><span>&raquo; </span><a href=https://docs.google.com/document/d/1i0W6qNfGMhTfwWTHBaaKzlN9HLGwbk3GLeh8VtVlhNM>Resume</a><li><span>&raquo; </span><a href=/archive.html#2006>All posts in 2006</a></ul><div id=social><div id=stalker><a href=https://github.com/MarioCarrion><i class="fa fa-github-square"></i></a><a href=http://stackoverflow.com/users/134327><i class="fa fa-stack-overflow"></i></a><a href=https://twitter.com/mariocarrion><i class="fa fa-twitter-square"></i></a><a href=https://www.linkedin.com/in/mariocarrion><i class="fa fa-linkedin-square"></i></a></div></div></nav></div><div class="eleven columns content"><p class=meta>May 01, 2006
<a href=/><i class="home fa fa-home"></i></a><h1 class=title>Notas de desempeÃ±o, 2</h1><div id=post><p>DespuÃ©s de haber hecho lo <a href=http://mario.monouml.org/index.php/2006/04/25/notas-de-desempeno/>antes comentado</a> y cambiar las clases por estructuras he notado que (sin la menor duda) se acelara el desempeÃ±o, he bajado la respuesta de 6~8 segundos a menos de un segundo, lo cual es algo grandioso, procesar mÃ¡s de 21000 estructuras de aproxidamente 1500 bytes cada una es fantÃ¡stico, el consumo de CPU es de 1%-3% (hablando de un P4 2.4Ghz), claro que este caso de prueba es "<em>el peor de los casos</em>" y tambiÃ©n, aÃºn, hay detalles que podrÃ­an ser mejorados, los resultados son excelentes. Durante la recepciÃ³n utilizo la soluciÃ³n del marshalling+cast, de modo que se hace un cast explÃ­cito al tipo de estructura, por ejemplo, suponiendo que tenemos una estructura definida como:<p><code lang=csharp>[StructLayout (LayoutKind.Explicit)]<br>public struct MyStruct<br>{<br>[FieldOffset (0)]<br>public int Integer;<p>[FieldOffset (4)]<br>public short Short;<br>}</code><p>PodrÃ­amos dentro de alguna parte de nuestra lÃ³gica de procesamiento del flujo binario, hacer el cast:<p><code lang=csharp>fixed (byte *data = reader.ReadBytes (sizeof (MyStruct))) {<br>header = *(MyStruct *) data;<br>}</code><p>Donde el flujo lo leemos a travÃ©s de la variable <em>reader</em> (BinaryReader). Lo mÃ¡s probable es que este proceso se encuentre dentro de un ciclo infinito que se encuentra recibiendo la informaciÃ³n del flujo de red. DespuÃ©s de unas pruebas, que hice por simple curiosidad, note algo muy interesante de las formas de obtener el tamaÃ±o de una definiciÃ³n de estructura y clase, lo mÃ¡s sorprendente fue que el mÃ©todo propuesto por "<em>Marshal.SizeOf (typeof (MyStruct))</em>", es mÃ¡s lento, y sin duda es cierto, pues cada ocasiÃ³n que es llamado se realiza un asignaciÃ³n por la CLR para calcular su tamaÃ±o.<pre>repetitions: 1000
iterations: 1.000000e+006

TestSizeOfStatic :      7.773 seconds
TestSizeOf:     2.781 seconds
TestSizeOfMarshal :     50.093 seconds</pre><p>Debido a que sizeof Ãºnicamente sirve para tipos por valor, no es posible aplicar este mÃ©todo a una clase y tendrÃ­amos que utilizar <em>Marshal.SizeOf</em> para obtener este tamaÃ±o, una soluciÃ³n para no afectar el desempeÃ±o y no utilizar siempre la opciÃ³n no recomendada es agregando una propiedad estÃ¡tica a nuestra clase ademÃ¡s de una variable privada estÃ¡tica que mantenga este tamaÃ±o, algo como:<p><code lang=csharp>[StructLayout (LayoutKind.Sequential)]<br>public class MyClass<br>{<br>public int Integer;<br>public short Short;<p>static unsafe MyClass ()<br>{<br>_size = Marshal.SizeOf (typeof (MyClass));<br>}<p>public static int Size<br>{<br>get { return _size; }<br>}<p>private static int _size;<br>}</code><p>AdemÃ¡s hay que recordar que el <em>overhead</em> de utilizar una clase en comparaciÃ³n a una estructura es mayor. Hay detalles en las clases, al igual que en las estructuras, que deben ser consideradas, el <a href=http://www.mono-project.com/Interop_with_Native_Libraries>sitio de mono</a> tiene algunos buenos consejos para esto.</div><div id=related><h3>Posts</h3><ul class=posts><li><span>All in 2016!</span> <a href=/archive.html#2006>All posts from this year</a></ul><ul class=posts><li><span>Apr 26, 2006</span> <a href=http://www.mariocarrion.com/2006/04/26/by-the-way.html>By the way</a><li><span>May 05, 2006</span> <a href=http://www.mariocarrion.com/2006/05/05/thinking-before-redrawing.html>Thinking before redrawing</a></ul></div><div class=footer><div class=disclaimer><p>The postings on this site are my own and do not represent my
<a href=http://www.meredith.com/>employer's</a> positions, strategies or opinions.<p>&copy; Mario Carrion, 2004-2016 &mdash; built with <a href=https://gohugo.io/>Hugo</a> using a heavily modified version of <a href=https://github.com/swanson/lagom>Lagom theme</a></div></div></div></div>analytics