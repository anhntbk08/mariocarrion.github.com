<!doctype html><html lang=en-us><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><meta name=author content="Mario Carrion"><meta name=description content="A pesar de todos los comentarios puristas, usualmente absurdos y sin fundamentos, referentes a la plataforma Mono (y MS .NET), escribir cÃ³digo en esa plataforma realmente agiliza el desarrollo, en .NET no todo es &#34;arrastrar y soltar&#34;, ni llenar las &#34;formas&#34; y cambiarles los colores arbitrariamente, ni hacer supuesta orientaciÃ³n a objetos copiando trozos de cÃ³digo (estÃ¡ticos por cierto) a diferentes mÃ©todos. Escribir cÃ³digo en .NET cualquiera lo puede hacer, pero el hacerlo bien requiere habilidades y experiencia en otros lenguajes."><meta property="og:title" content="Notas de desempeÃ±o"><meta property="og:description" content="A pesar de todos los comentarios puristas, usualmente absurdos y sin fundamentos, referentes a la plataforma Mono (y MS .NET), escribir cÃ³digo en esa plataforma realmente agiliza el desarrollo, en .NET no todo es &#34;arrastrar y soltar&#34;, ni llenar las &#34;formas&#34; y cambiarles los colores arbitrariamente, ni hacer supuesta orientaciÃ³n a objetos copiando trozos de cÃ³digo (estÃ¡ticos por cierto) a diferentes mÃ©todos. Escribir cÃ³digo en .NET cualquiera lo puede hacer, pero el hacerlo bien requiere habilidades y experiencia en otros lenguajes."><meta property="og:type" content="article"><meta property="og:url" content="https://www.mariocarrion.com/2006/04/25/notas-de-desempeno.html"><meta property="article:published_time" content="2006-04-25T22:30:57&#43;00:00"><meta property="article:modified_time" content="2006-04-25T22:30:57&#43;00:00"><title>Notas de desempeÃ±o</title><link rel=canonical href=https://www.mariocarrion.com/2006/04/25/notas-de-desempeno.html><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Inconsolata:400,700" rel=stylesheet><link rel=stylesheet href=/css/reset.css><link rel=stylesheet href=/css/main.css><link rel="shortcut icon" href=/favicon.png><link rel=alternate type=application/rss+xml title="RSS Feed" href=/index.xml><body><section class=header><div class=container><div class=content><a href=/><img class=avatar src=/img/logo.png></a>
<a href=/><div class=name>Mario Carrion</div></a><nav><ul><li class=nav-about><a href=https://www.mariocarrion.com/about.html><span>About</span></a><li class=nav-archive><a href=https://www.mariocarrion.com/archive.html><span>All Posts</span></a><li class=nav-books><a href=https://www.mariocarrion.com/books.html><span>Books</span></a><li class=nav-resume><a href=https://docs.google.com/document/d/1i0W6qNfGMhTfwWTHBaaKzlN9HLGwbk3GLeh8VtVlhNM><span>Resume</span></a></ul></nav></div></div></section><section class=icons><div class=container><div class=content><a href=/index.xml><img class=icon src=/img/rss.svg alt=rss></a>
<a href=//twitter.com/MarioCarrion target=_blank rel=noopener><img class=icon src=/img/twitter.svg alt=twitter></a>
<a href=//gitlab.com/MarioCarrion target=_blank rel=noopener><img class=icon src=/img/gitlab.svg alt=gitlab></a>
<a href=//github.com/MarioCarrion target=_blank rel=noopener><img class=icon src=/img/github.svg alt=github></a>
<a href=//linkedin.com/in/MarioCarrion target=_blank rel=noopener><img class=icon src=/img/linkedin.svg alt=linkedin></a></div></div></section><section class="main post non-narrow zero-top-spacing"><div class=container><div class=content><div class=front-matter><div class=title-container><div class=page-heading>Notas de desempeÃ±o</div><div class=initials><a href=https://www.mariocarrion.com></a></div></div><div class=meta><div class=date title="Tue Apr 25 2006 22:30:57 UTC">Apr 25, 2006</div></div></div><div class=markdown><p>A pesar de todos los comentarios puristas, usualmente absurdos y sin fundamentos, referentes a la plataforma <a href=http://www.mono-project.com>Mono</a> (y MS .NET), escribir cÃ³digo en esa plataforma realmente agiliza el desarrollo, en .NET no todo es "arrastrar y soltar", ni llenar las "formas" y cambiarles los colores arbitrariamente, ni hacer supuesta orientaciÃ³n a objetos copiando trozos de cÃ³digo (estÃ¡ticos por cierto) a diferentes mÃ©todos. Escribir cÃ³digo en .NET cualquiera lo puede hacer, pero el hacerlo bien requiere habilidades y experiencia en <a href=http://en.wikipedia.org/wiki/C_programming_language>otros</a> <a href=http://en.wikipedia.org/wiki/C%2B%2B>lenguajes</a>.<p>PodrÃ­amos pensar para escribir una aplicaciÃ³n de tiempo real debemos seleccionar un lenguaje que pueda al final general un binario dependiente de <a href=http://en.wikipedia.org/wiki/Platform_%28computing%29>plataforma</a> y <a href=http://en.wikipedia.org/wiki/Computer_architecture>arquitectura</a>, de esta forma se podrÃ¡n explotar, entre otras cosas, las capacidades de CPU y un manejo adecuado de memoria y administraciÃ³n de esta, Â¿QuÃ© es lo malo?, hay que saber como hacerlo y aprender lleva tiempo y tiempo es dinero, mÃ¡s tiempo significa mÃ¡s inversiÃ³n y eso es algo de lo que usualmente no disponemos, ademÃ¡s la plataforma que se ofrece a travÃ©s de la conjunciÃ³n del <a href=http://en.wikipedia.org/wiki/Common_Language_Runtime>CLR</a> y el <a href=http://en.wikipedia.org/wiki/Common_Intermediate_Language>CIL</a> hacen que podamos tener lo mejor de los dos mundos, hacer que el tiempo de desarrollo se reduzca y el desempeÃ±o sea al menos semejante a una aplicaciÃ³n de arquitectura y plataforma dependiente, es obvio que un desempeÃ±o excelente en comparaciÃ³n a un compilado-dependiente no se podrÃ¡ obtener, pero sin embargo siempre se busca el mejor.<p>Mi proyecto actual del trabajo es el claro ejemplo del extremo, donde se debe escribir una aplicaciÃ³n en .NET con un desempeÃ±o excelente, el retardo mÃ¡ximo de actualizaciÃ³n es de 3 segundos, actualmente lo he bajado de 6-8 a 3-1 segundos, cosa que me agrada, pero seguro se puede mejorar mÃ¡s, algunas cosas que me ayudaron a mejorar el desempeÃ±o fue:<ol><li>Parar el uso de Enumeradores, reemplazalos con punteros, con cÃ³digo no administrado.<li>No usar indexadores para acceder a arreglos cambiando el cÃ³digo a un uso de aritmÃ©tica de punteros, con cÃ³digo no administrado.<li>Concatenaciones a travÃ©z de System.Text.StringBuilder, en vez de utilizar el clÃ¡sico "<em>cadena + cadena</em>".<li>DÃ©bido a que recibo informaciÃ³n binaria de estructuras escritas en C mediante un broadcast, es necesario generar las versiones C# correspondientes a aquellas struct en C con un Marshalling de modo que se pueda hacer un casting de tipo <em>*(Estructura *) ptr</em>.</ol><p>Existe <a href=http://www.codeproject.com/csharp/iter_perf.asp>un artÃ­culo</a> que muestra un buen caso de ejemplo indicando desempeÃ±o al momento de hacer ciclos a arreglos, dentro se utiliza un ejemplo de punteros escritos en C++ administrado, la versiÃ³n de C# serÃ­a algo asÃ­:<p><code lang=csharp>using System;<p>namespace Iterations<br>{<br>public class Pointer<br>{<br>public unsafe static void iterate (Data data)<br>{<br>double d;<br>fixed (double *ptr = &data.Array [0]) {<br>int l = data.Array.Length;<br>for (int i = 0; i < l; i++)<br>d = *(ptr +i);<br>}<br>}<br>}<br>}</code><p>Los resultados son contundentes:<p></code><code lang=genero>repetitions: 1000<br>iterations: 1.000000e+006<p>Enumeration: 32.87 seconds<br>Indexing: 11.246 seconds<br>Indirect Arrays: 10.172 seconds<br>Direct Arrays: 5.44 seconds<br>Pointer Math: 4.828 seconds</code><p>El retardo principal se debe a los objetos generados durante la enumeraciÃ³n, <em>foreach</em> no es la elecciÃ³n en aplicaciones de alto desempeÃ±o, sin duda es sencillo de implementar pero es lento al ejecutar, la soluciÃ³n mÃ¡s rÃ¡pida a travÃ©z de punteros se debe a que validaciones como el Ã­ndice del arreglo no es considerado, dejando todo la lÃ³gica de validaciÃ³n al programador.<p>Hay cosas que me faltan de eliminar como ese abuso exagerado de boxing/unboxing al momento de tener mi colecciÃ³n de estructuras recibidas por el broadcast, ademÃ¡s de la creaciÃ³n innecesario de tipos por valor, reemplazando con una lista enlazada en cÃ³digo no administrado y pasos por referencia respectivamente. Un ejemplo de esto serÃ­a:<p><code lang=csharp>using System;<p>namespace Research<br>{<br>unsafe public struct MyStruct<br>{<br>public MyStruct (int integer)<br>{<br>Integer = integer;<br>Next = null;<br>}<p>public int Integer;<br>public MyStruct *Next;<p>public override string ToString ()<br>{<br>return "Integer: "+Integer+" at "+<br>"Ptr "+((int)&(*Next));<br>}<br>}<p>//Quick sample, don't bother me ;-)<br>public class Sample<br>{<br>unsafe public static void Main (string []args)<br>{<br>MyStruct obj1 = new MyStruct ();<br>MyStruct obj2 = new MyStruct ();<br>obj1.Next = null;<br>obj2.Next = &obj1;<br>obj1.Integer = 1;<br>obj2.Integer = 2;<br>ChangeByPointer (&obj1.Integer);<br>ChangeByReference (ref obj2.Integer);<br>Console.WriteLine (obj1 +" * "+ obj2);<br>}<p>unsafe public static void ChangeByPointer (int *reference)<br>{<br>*(reference) += 5;<br>}<p>unsafe public static void ChangeByReference (ref int reference)<br>{<br>reference += 5;<br>}<br>}<br>}</code><p>Algo interesante es el hecho de que ambos mÃ©todos generan la misma secuencia de instrucciones CIL, lo cual obviamente indica que son iguales, por tal razÃ³n cualquier elecciÃ³n es buena:<p><code lang=asm>//... more before<p>// method line 5<br>.method public static hidebysig<br>default void ChangeByPointer (int32* reference) cil managed<br>{<br>// Method begins at RVA 0x21c4<br>// Code size 7 (0x7)<br>.maxstack 8<br>IL_0000: ldarg.0<br>IL_0001: dup<br>IL_0002: ldind.i4<br>IL_0003: ldc.i4.5<br>IL_0004: add<br>IL_0005: stind.i4<br>IL_0006: ret<br>} // end of method Sample::default void ChangeByPointer (int32* reference)<p>// method line 6<br>.method public static hidebysig<br>default void ChangeByReference (int32& reference) cil managed<br>{<br>// Method begins at RVA 0x21cc<br>// Code size 7 (0x7)<br>.maxstack 8<br>IL_0000: ldarg.0<br>IL_0001: dup<br>IL_0002: ldind.i4<br>IL_0003: ldc.i4.5<br>IL_0004: add<br>IL_0005: stind.i4<br>IL_0006: ret<br>} // end of method Sample::default void ChangeByReference (int32& reference)<br>//more later...</code><p>Faltan detalles por mejorar, pero sin duda "jugar" con punteros siempre serÃ¡ lo mejor.</p><br><p class=back-to-posts><a href=/archive.html>Back to posts</a></div><br><div class=disqus></div></div></div></section>